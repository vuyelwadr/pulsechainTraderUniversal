"""
Backtesting Engine for HEX Trading Bot
Simulates trading strategies on historical data
"""
import pandas as pd
import numpy as np
from datetime import datetime, timedelta
from decimal import Decimal
import logging
from typing import Dict, List, Optional, Tuple
import json
import os

from bot.config import Config
from strategies.base_strategy import BaseStrategy
from collectors.reserve_fetcher import get_reserve_fetcher
from utils.swap_cost_cache import get_swap_cost_cache, SwapCostCacheError

logger = logging.getLogger(__name__)

class BacktestEngine:
    """Backtesting engine for trading strategies"""
    
    def __init__(self, initial_balance: float = None, pool_reserves: Dict[str, Tuple[int, int]] = None, slippage_pct: float = 0.01):
        self.config = Config()
        self.initial_balance = Decimal(str(initial_balance or self.config.INITIAL_BALANCE))
        self.pool_reserves = pool_reserves or {}  # pair_address -> (reserve0, reserve1)
        self.slippage_pct = slippage_pct  # Store for open position valuation
        self.reserve_fetcher = get_reserve_fetcher()
        self.reset()
        try:
            self.swap_cost_cache = get_swap_cost_cache()
        except SwapCostCacheError as exc:
            raise RuntimeError(
                "Swap cost cache unavailable; ensure the runner/backtest "
                "initialised the Piteas swap cost cache before executing a backtest."
            ) from exc
        
    def reset(self):
        """Reset backtest state"""
        self.balance = self.initial_balance
        self.hex_balance = Decimal('0')
        self.trades = []
        self.portfolio_history = []
        self.position = None  # 'long', 'short', or None
        self.entry_price = None
        self.entry_time = None
        self.total_fees = Decimal('0')
        self.max_drawdown = Decimal('0')
        self.peak_balance = self.initial_balance
        
    def run_backtest(self, strategy: BaseStrategy, data: pd.DataFrame,
                    trade_amount_pct: Optional[float] = None, slippage_pct: float = 0.01,
                    volume_based_slippage: bool = True) -> Dict:
        """
        Run backtest on historical data
        
        Args:
            strategy: Trading strategy to test
            data: Historical price data
            trade_amount_pct: Percentage of balance to use per trade (0.0-1.0)
            slippage_pct: Fallback slippage percentage (0.01 = 1%)
            volume_based_slippage: Use volume-aware slippage if volume data available
            
        Returns:
            Dictionary with backtest results
        """
        if data.empty:
            return {'error': 'No data provided for backtesting'}
        
        logger.info(f"Starting backtest for {strategy.name} on {len(data)} data points")
        
        self.reset()
        self.slippage_pct = slippage_pct
        
        # Calculate indicators and signals for all data at once
        data_with_indicators = strategy.calculate_indicators(data.copy())
        signals_data = strategy.generate_signals(data_with_indicators)
        
        if signals_data.empty:
            return {'error': 'No signals generated by strategy'}
        
        if trade_amount_pct is None:
            params = getattr(strategy, 'parameters', {}) or {}
            trade_amount_pct = params.get('trade_amount_pct', getattr(strategy, 'trade_amount_pct', 1.0))
        try:
            trade_amount_pct = float(trade_amount_pct)
        except (TypeError, ValueError):
            trade_amount_pct = 1.0
        trade_amount_pct = min(1.0, max(0.0, trade_amount_pct))  # Clamp to 0-100%
        slippage_pct = min(0.1, max(0.0, slippage_pct))  # Clamp between 0% and 10%
        
        # Simulate trading through the data
        for i in range(len(signals_data)):
            current_data = signals_data.iloc[i]
            
            # Process the current signal
            self._process_signal(
                current_data,
                trade_amount_pct,
                slippage_pct,
                i,
                volume_based_slippage
            )
            
            # Record portfolio state
            self._record_portfolio_state(current_data)
        
        # Close any open position at the end
        if self.position:
            price_col = 'price' if 'price' in signals_data.columns else 'close'
            final_price = Decimal(str(float(signals_data.iloc[-1][price_col])))  # Convert to Decimal
            final_time = signals_data.iloc[-1]['timestamp']
            self._close_position(final_price, final_time, 'backtest_end')
        
        # Calculate results
        results = self._calculate_results(signals_data)
        
        logger.info(f"Backtest completed: {len(self.trades)} trades, "
                   f"Final balance: {self.balance:.4f} DAI")
        
        return results
    
    def _process_signal(self, current_data: pd.Series, trade_amount_pct: float,
                        slippage_pct: float, index: int, volume_based_slippage: bool):
        """Process a single trading signal with slippage"""
        # Use 'close' column as price if 'price' doesn't exist
        price_col = 'price' if 'price' in current_data else 'close'
        base_price = Decimal(str(float(current_data[price_col])))  # Ensure float conversion first
        # Convert timestamp to datetime if it's a string
        timestamp = current_data['timestamp']
        if isinstance(timestamp, str):
            timestamp = pd.to_datetime(timestamp)
        
        _ = volume_based_slippage  # retained for signature compatibility
        buy_signal = current_data.get('buy_signal', False)
        sell_signal = current_data.get('sell_signal', False)
        signal_strength = current_data.get('signal_strength', 0.0)
        
        # Skip if no signal (signal_strength of 0 means no signal)
        # Let strategies control their own minimum thresholds
        if signal_strength <= 0:
            return
        
        # Buy signal - enter long position using cached swap costs
        if buy_signal and self.position != 'long':
            if self.position == 'short':
                # Support for short positions not implemented; ignore for now
                pass

            trade_amount = self.balance * Decimal(str(trade_amount_pct))

            if trade_amount > Decimal('0.01'):  # Minimum trade amount
                cost_info = self.swap_cost_cache.compute_buy(trade_amount)
                asset_received = cost_info['asset_received']
                if asset_received > Decimal('0'):
                    executed_price = cost_info['amount_in_dai'] / asset_received
                else:
                    executed_price = base_price

                self.balance -= cost_info['amount_in_dai']
                self.hex_balance += asset_received
                self.total_fees += cost_info['cost_dai']

                trade = {
                    'timestamp': timestamp,
                    'type': 'buy',
                    'price': float(executed_price),
                    'quote_amount': float(cost_info['amount_in_dai']),
                    'hex_amount': float(asset_received),
                    'fee': float(cost_info['cost_dai']),
                    'signal_strength': signal_strength,
                    'balance_after': float(self.balance),
                    'index': index,
                    'slippage_pct': float(cost_info['loss_rate'] * Decimal('100')),
                    'cost_rung_dai': float(cost_info['rung']),
                    'cost_implied_sell_dai': float(cost_info['implied_sell_dai']),
                    'cost_token_per_dai': float(cost_info['token_per_dai']),
                    'cost_dai_per_token': float(cost_info['dai_per_token']),
                    'cost_roundtrip_loss_dai': float(cost_info['roundtrip_loss_dai']),
                }

                self.trades.append(trade)

                self.position = 'long'
                self.entry_price = executed_price
                self.entry_time = timestamp

                logger.debug(
                    f"BUY: {asset_received:.4f} HEX at {executed_price:.8f} DAI "
                    f"(cache rung {cost_info['rung']})"
                )
        
        # Sell signal - exit long position
        elif sell_signal and self.position == 'long':
            self._close_position(base_price, timestamp, 'sell_signal', signal_strength, index)

    def _calculate_volume_slippage(self, trade_size_quote: Decimal, bar_volume: float,
                                   base_price: Decimal, side: str) -> Decimal:
        """Calculate slippage using constant product AMM math with cached reserves"""
        if trade_size_quote <= 0 or base_price <= 0:
            return Decimal('1')
        
        try:
            # For PDAI trades, we need to handle multi-hop slippage: DAI -> WPLS -> PDAI
            slippage_multiplier = self._calculate_reserve_slippage(trade_size_quote, base_price, side)
            return slippage_multiplier
        except Exception as e:
            logger.error(f"Reserve-based slippage calculation failed: {e}, no reserves available")
            raise RuntimeError(f"Cannot calculate slippage without pool reserves: {e}")

    def _calculate_reserve_slippage(self, trade_size_quote: Decimal, price: Decimal, side: str) -> Decimal:
        """Calculate slippage using constant product formula with pool reserves"""
        # Ensure all inputs are Decimal to prevent type errors
        trade_size_quote = Decimal(trade_size_quote)
        price = Decimal(price)
        
        # For PDAI, we need reserves for both DAI/WPLS and WPLS/PDAI pools
        # Since we're trading PDAI vs DAI, and PDAI price is in DAI terms
        
        if not self.pool_reserves:
            logger.warning("No pool reserves available, using minimal slippage")
            return Decimal('1.001') if side == 'buy' else Decimal('0.999')
        
        # Get PDAI/WPLS and WPLS/DAI reserves (assuming PDAI trades through WPLS)
        pdai_wpls_pair = self._get_pair_address(self.config.ASSET_ADDRESS, self.config.WPLS_ADDRESS)
        wpls_dai_pair = self._get_pair_address(self.config.WPLS_ADDRESS, self.config.DAI_ADDRESS)
        
        pdai_wpls_reserves = self.pool_reserves.get(pdai_wpls_pair)
        wpls_dai_reserves = self.pool_reserves.get(wpls_dai_pair)
        
        if not pdai_wpls_reserves or not wpls_dai_reserves:
            logger.warning("Missing reserves for PDAI trading path, using minimal slippage")
            return Decimal('1.001') if side == 'buy' else Decimal('0.999')
        
        # Convert reserves to Decimal for precision
        pdai_reserve = Decimal(str(pdai_wpls_reserves[0]))
        wpls_reserve_pdai = Decimal(str(pdai_wpls_reserves[1]))
        wpls_reserve_dai = Decimal(str(wpls_dai_reserves[0]))
        dai_reserve = Decimal(str(wpls_dai_reserves[1]))
        
        # Normalize reserves to same decimal places (assuming 18 decimals for all tokens)
        # This is a simplification - in reality we'd need proper decimal handling
        
        if side == 'buy':
            # Buying PDAI with DAI: DAI -> WPLS -> PDAI
            # trade_size_quote is in DAI, we want PDAI amount
            dai_amount = trade_size_quote
            
            # First hop: DAI -> WPLS
            wpls_out = self._calculate_single_swap_output(dai_amount, dai_reserve, wpls_reserve_dai)
            
            # Second hop: WPLS -> PDAI  
            pdai_out = self._calculate_single_swap_output(wpls_out, wpls_reserve_pdai, pdai_reserve)
            
            # Expected PDAI without slippage
            expected_pdai = dai_amount / price
            
            if expected_pdai <= 0:
                return Decimal('1')
                
            # Effective price = DAI spent / PDAI received
            # Since we spend dai_amount and receive pdai_out, effective_price = dai_amount / pdai_out
            effective_price = dai_amount / pdai_out
            
            # Slippage multiplier = effective_price / base_price
            slippage_multiplier = effective_price / price
            
        else:  # sell
            # Selling PDAI for DAI: PDAI -> WPLS -> DAI
            # trade_size_quote is in DAI value of PDAI being sold
            pdai_amount = trade_size_quote / price
            
            # First hop: PDAI -> WPLS
            wpls_out = self._calculate_single_swap_output(pdai_amount, pdai_reserve, wpls_reserve_pdai)
            
            # Second hop: WPLS -> DAI
            dai_out = self._calculate_single_swap_output(wpls_out, wpls_reserve_dai, dai_reserve)
            
            # Expected DAI without slippage
            expected_dai = trade_size_quote
            
            if expected_dai <= 0:
                return Decimal('1')
                
            # Effective price = DAI received / PDAI sold
            # Since we sell pdai_amount and receive dai_out, effective_price = dai_out / pdai_amount
            effective_price = dai_out / pdai_amount
            
            # Slippage multiplier = effective_price / base_price
            slippage_multiplier = effective_price / price
        
        # Ensure reasonable bounds
        # For buys: slippage_multiplier >= 1.0 (pay more or equal)
        # For sells: slippage_multiplier <= 1.0 (get less or equal)
        # Cap extreme slippage at 10x for buys, 0.1x for sells
        if side == 'buy':
            slippage_multiplier = max(Decimal('1.0'), min(Decimal('10.0'), slippage_multiplier))
        else:
            slippage_multiplier = max(Decimal('0.1'), min(Decimal('1.0'), slippage_multiplier))
        
        return slippage_multiplier

    def _calculate_single_swap_output(self, input_amount: Decimal, input_reserve: Decimal, 
                                    output_reserve: Decimal) -> Decimal:
        """Calculate output amount for a single swap using constant product formula"""
        if input_reserve <= 0 or output_reserve <= 0 or input_amount <= 0:
            return Decimal('0')
        
        # Constant product formula: (x + dx) * (y - dy) = x * y
        # dy = (dx * y) / (x + dx)
        return (input_amount * output_reserve) / (input_reserve + input_amount)

    def _get_pair_address(self, token0: str, token1: str) -> str:
        """Get the pair address for two tokens (must match reserve_fetcher logic)"""
        return self.reserve_fetcher.get_pair_address(token0, token1)

    @staticmethod
    def _interpolate_slippage(volume_pct: float) -> float:
        """Piecewise linear interpolation for slippage curve based on volume share"""
        points = [
            (0.0, 0.0),
            (0.01, 0.001),
            (0.05, 0.015),
            (0.1, 0.025),
            (0.2, 0.05),
            (0.5, 0.15),
            (1.0, 0.3)
        ]
        if volume_pct <= points[0][0]:
            return points[0][1]
        for i in range(1, len(points)):
            x0, y0 = points[i - 1]
            x1, y1 = points[i]
            if volume_pct <= x1:
                if x1 == x0:
                    return y1
                ratio = (volume_pct - x0) / (x1 - x0)
                return y0 + ratio * (y1 - y0)
        # Beyond final anchor, extrapolate with last segment but cap via caller
        x0, y0 = points[-2]
        x1, y1 = points[-1]
        if x1 == x0:
            return y1
        ratio = min(1.0, (volume_pct - x0) / (x1 - x0))
        return y0 + ratio * (y1 - y0)
    
    def _close_position(self, price: Decimal, timestamp, reason: str, 
                       signal_strength: float = 1.0, index: int = None):
        """Close current position"""
        if self.position != 'long' or self.hex_balance <= 0:
            return
        
        hex_sold = self.hex_balance
        if hex_sold <= 0:
            return

        estimated_notional = hex_sold * price
        cost_info = self.swap_cost_cache.compute_sell(hex_sold, estimated_notional)
        quote_net = cost_info['net_dai']
        executed_price = quote_net / hex_sold if hex_sold > Decimal('0') else price

        self.balance += quote_net
        self.hex_balance = Decimal('0')
        self.total_fees += cost_info['cost_dai']

        if self.entry_price:
            pnl = ((executed_price - self.entry_price) / self.entry_price) * Decimal('100')
            pnl_quote = quote_net - (hex_sold * self.entry_price)
        else:
            pnl = Decimal('0')
            pnl_quote = Decimal('0')

        trade = {
            'timestamp': timestamp,
            'type': 'sell',
            'price': float(executed_price),
            'quote_amount': float(quote_net),
            'hex_amount': float(hex_sold),
            'fee': float(cost_info['cost_dai']),
            'signal_strength': signal_strength,
            'balance_after': float(self.balance),
            'pnl_pct': float(pnl),
            'pnl_quote': float(pnl_quote),
            'entry_price': float(self.entry_price) if self.entry_price else 0,
            'entry_time': self.entry_time,
            'hold_duration': str(timestamp - self.entry_time) if self.entry_time else None,
            'reason': reason,
            'index': index or 0,
            'slippage_pct': float(cost_info['loss_rate'] * Decimal('100')),
            'cost_rung_dai': float(cost_info['rung']),
            'cost_approx_input_dai': float(cost_info['approx_input_dai']),
            'cost_token_per_dai': float(cost_info['token_per_dai']),
            'cost_dai_per_token': float(cost_info['dai_per_token']),
            'cost_roundtrip_loss_dai': float(cost_info['roundtrip_loss_dai']),
        }

        self.trades.append(trade)

        self.position = None
        self.entry_price = None
        self.entry_time = None

        logger.debug(
            f"SELL: {hex_sold:.4f} HEX at {executed_price:.8f} DAI, "
            f"P&L: {pnl:.2f}% (cache rung {cost_info['rung']})"
        )
    
    def _record_portfolio_state(self, current_data: pd.Series):
        """Record current portfolio state for analysis"""
        price_col = 'price' if 'price' in current_data else 'close'
        price = Decimal(str(float(current_data[price_col])))  # Ensure float conversion first
        timestamp = current_data['timestamp']
        
        # Calculate total portfolio value
        if self.position == 'long':
            # Apply sell slippage for open position valuation
            sell_price = price * (Decimal('1') - Decimal(str(self.slippage_pct)))
            hex_value = self.hex_balance * sell_price
        else:
            hex_value = self.hex_balance * price
        total_value = self.balance + hex_value
        
        # Update peak balance and max drawdown
        if total_value > self.peak_balance:
            self.peak_balance = total_value
        
        drawdown = (self.peak_balance - total_value) / self.peak_balance
        if drawdown > self.max_drawdown:
            self.max_drawdown = drawdown
        
        # Record state
        state = {
            'timestamp': timestamp,
            'price': float(price),
            'quote_balance': float(self.balance),
            'hex_balance': float(self.hex_balance),
            'hex_value_quote': float(hex_value),
            'total_value': float(total_value),
            'position': self.position,
            'drawdown': float(drawdown)
        }
        
        self.portfolio_history.append(state)
    
    def _calculate_results(self, data: pd.DataFrame) -> Dict:
        """Calculate comprehensive backtest results"""
        if not self.trades:
            return {
                'strategy': 'No trades executed',
                'initial_balance': float(self.initial_balance),
                'final_balance': float(self.balance),
                'total_return': 0.0,
                'error': 'No trades were executed'
            }
        
        # Basic metrics
        price_col = 'price' if 'price' in data.columns else 'close'
        final_balance = self.balance + (self.hex_balance * Decimal(str(data.iloc[-1][price_col])))
        total_return = (final_balance - self.initial_balance) / self.initial_balance * 100
        
        # Trade analysis
        buy_trades = [t for t in self.trades if t['type'] == 'buy']
        sell_trades = [t for t in self.trades if t['type'] == 'sell']
        
        # P&L analysis from sell trades
        profitable_trades = [t for t in sell_trades if t.get('pnl_pct', 0) > 0]
        losing_trades = [t for t in sell_trades if t.get('pnl_pct', 0) < 0]
        
        win_rate = (len(profitable_trades) / len(sell_trades) * 100) if sell_trades else 0
        
        avg_win = np.mean([t['pnl_pct'] for t in profitable_trades]) if profitable_trades else 0
        avg_loss = np.mean([t['pnl_pct'] for t in losing_trades]) if losing_trades else 0
        
        # Risk metrics
        if self.portfolio_history:
            portfolio_df = pd.DataFrame(self.portfolio_history)
            portfolio_df['returns'] = portfolio_df['total_value'].pct_change()
            
            volatility = portfolio_df['returns'].std() * np.sqrt(365 * 24 * 12) * 100  # Annualized for 5-min bars
            
            # Sharpe ratio (simplified, assuming 0% risk-free rate)
            mean_return = portfolio_df['returns'].mean()
            sharpe_ratio = (mean_return / portfolio_df['returns'].std()) if portfolio_df['returns'].std() > 0 else 0
            sharpe_ratio *= np.sqrt(365 * 24 * 12)  # Annualized for 5-min bars
        else:
            volatility = 0
            sharpe_ratio = 0
        
        # Time analysis
        start_time = data.iloc[0]['timestamp']
        end_time = data.iloc[-1]['timestamp']
        # Convert to datetime if strings
        if isinstance(start_time, str):
            start_time = pd.to_datetime(start_time)
        if isinstance(end_time, str):
            end_time = pd.to_datetime(end_time)
        duration = end_time - start_time
        
        results = {
            # Basic metrics
            'strategy_name': 'Backtest Results',
            'start_time': start_time.strftime('%Y-%m-%d %H:%M:%S'),
            'end_time': end_time.strftime('%Y-%m-%d %H:%M:%S'),
            'duration_days': duration.days,
            'data_points': len(data),
            
            # Performance
            'initial_balance': float(self.initial_balance),
            'final_balance': float(final_balance),
            'total_return_pct': float(total_return),
            'total_fees': float(self.total_fees),
            
            # Trading metrics
            'total_trades': len(self.trades),
            'buy_trades': len(buy_trades),
            'sell_trades': len(sell_trades),
            'win_rate_pct': float(win_rate),
            'profitable_trades': len(profitable_trades),
            'losing_trades': len(losing_trades),
            
            # P&L metrics
            'avg_win_pct': float(avg_win),
            'avg_loss_pct': float(avg_loss),
            'profit_factor': float(abs(avg_win / avg_loss)) if avg_loss != 0 else 0,
            
            # Risk metrics
            'max_drawdown_pct': float(self.max_drawdown * 100),
            'volatility_pct': float(volatility),
            'sharpe_ratio': float(sharpe_ratio),
            
            # Additional data
            'trades': self.trades,
            'portfolio_history': self.portfolio_history
        }
        
        return results
    
    def save_results(self, results: Dict, filename: str = None):
        """Save backtest results to file"""
        if filename is None:
            timestamp = datetime.now().strftime('%Y%m%d_%H%M%S')
            filename = os.path.join(self.config.DATA_DIR, f"backtest_results_{timestamp}.json")
        
        try:
            # Make results JSON serializable
            json_results = json.loads(json.dumps(results, default=str))
            
            with open(filename, 'w') as f:
                json.dump(json_results, f, indent=2)
            
            logger.info(f"Results saved to {filename}")
            return filename
            
        except Exception as e:
            logger.error(f"Error saving results: {e}")
            return None
    
    def get_trade_summary(self) -> str:
        """Get a formatted summary of trades"""
        if not self.trades:
            return "No trades executed"
        
        buy_trades = [t for t in self.trades if t['type'] == 'buy']
        sell_trades = [t for t in self.trades if t['type'] == 'sell']
        
        summary = f"Trade Summary:\n"
        summary += f"  Total trades: {len(self.trades)}\n"
        summary += f"  Buy orders: {len(buy_trades)}\n"
        summary += f"  Sell orders: {len(sell_trades)}\n"
        summary += f"  Total fees: {self.total_fees:.6f} DAI\n"
        
        if sell_trades:
            profitable = [t for t in sell_trades if t.get('pnl_pct', 0) > 0]
            win_rate = len(profitable) / len(sell_trades) * 100
            avg_pnl = np.mean([t.get('pnl_pct', 0) for t in sell_trades])
            
            summary += f"  Win rate: {win_rate:.1f}%\n"
            summary += f"  Average P&L: {avg_pnl:.2f}%\n"
        
        return summary
